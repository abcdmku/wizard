# Defining Flows

The core of any wizard is its flow definition. This guide covers how to define steps, control navigation, and use the factory pattern for maximum type safety.

## The Factory Pattern

The recommended way to create a wizard is using the `wizardWithContext` factory. This ensures your context and data types are automatically inferred throughout the entire wizard definition.

```typescript
import { wizardWithContext } from '@wizard/core';

// 1. Define your shared context type
interface AppContext {
  userId: string;
  theme: 'light' | 'dark';
}

// 2. Create the factory
const { defineSteps, createWizard, step } = wizardWithContext<AppContext>({
  userId: '',
  theme: 'light'
});
```

Using this pattern, `step`, `defineSteps`, and `createWizard` are all pre-bound to your `AppContext`.

## Step Definitions

Use the `step()` helper to define each step in your flow. It automatically infers the data shape from the `data` property.

```typescript
const steps = defineSteps({
  // A simple step with data
  personalInfo: step({
    data: { name: '', email: '' }, 
    next: ['preferences']
  }),

  // A step with logic
  preferences: step({
    data: { newsletter: false },
    canEnter: ({ context }) => !!context.userId, // Context is typed!
    next: ['review']
  }),

  // A final review step
  review: step({
    next: [] // No next steps -> terminal step
  })
});

const wizard = createWizard(steps);
```

### Step Helpers

In addition to the standard `step()`, several specialized helpers make common patterns easier:

| Helper | Use Case | Example |
| :--- | :--- | :--- |
| `step()` | flexible, general purpose | `step({ data: {...}, next: [...] })` |
| `dataStep()` | Simple data collection, no logic | `dataStep({ key: 'val' }, ['next'])` |
| `transitionStep()` | Logic-only, no UI/Data | `transitionStep(['next'])` |
| `conditionalStep()` | Dynamic branching | `conditionalStep({ next: (ctx) => ... })` |

## Navigation Logic

### Linear Navigation
For simple linear flows, pass an array of possible next steps strings.

```typescript
step({
  next: ['billing']
})
```

### Conditional Branching
For dynamic flows, pass a function to `next`.

```typescript
step({
  data: { paymentMethod: 'card' as 'card' | 'paypal' },
  next: ({ data }) => {
    return data.paymentMethod === 'card' ? ['creditCard'] : ['paypalLogin'];
  }
})
```

### Guards (`canEnter` / `canExit`)
Control flow with guard functions. These can be async.

```typescript
step({
  canEnter: async ({ context }) => {
    const hasPermission = await checkUserPermission(context.userId);
    return hasPermission;
  },
  canExit: ({ data }) => {
    return data.isValid;
  }
})
```

## Next Steps
- Learn about [State Management](/essentials/state-management) to share data between steps.
- Add [Validation](/essentials/validation) to your steps.
