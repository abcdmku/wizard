# Recipes

import { Callout, Tabs, Tab } from '../components'
import { InlineDemo } from '../components/Demo'
import {
  CodePlayground,
  StepBranchingDemo,
  AutoSaveDemo,
  ProgressTrackingDemo,
  AsyncLoadingDemo,
  RouterDemo,
  StepTimeoutDemo,
  AnalyticsDemo,
  StatusSystemDemo,
  HelpersShowcaseDemo,
  DAGPrerequisitesDemo,
  WeightedProgressDemo
} from '../components/InteractiveDemos'

Common patterns and solutions for building wizards with the new advanced features.

## Dynamic Step Branching

Create wizards with conditional paths based on user input:

<StepBranchingDemo variant="full" />

```typescript
const wizard = createWizard({
  initialStep: 'userType',
  steps: {
    userType: {
      next: ['individual', 'business'],
      onExit: (context, data) => ({
        ...context,
        userType: data.type
      })
    },
    individual: {
      next: ['payment'],
      prev: ['userType'],
      canEnter: (context) => context.userType === 'individual'
    },
    business: {
      next: ['taxInfo', 'payment'],
      prev: ['userType'],
      canEnter: (context) => context.userType === 'business'
    },
    taxInfo: {
      next: ['payment'],
      prev: ['business']
    },
    payment: {
      next: [],
      prev: ['individual', 'business', 'taxInfo']
    }
  }
});

// Dynamic step flow based on user type
function getStepFlow(userType: string | null): string[] {
  if (!userType) return ['userType'];
  
  if (userType === 'individual') {
    // Individual flow: User Type → Individual Info → Payment
    return ['userType', 'individual', 'payment'];
  }
  
  // Business flow: User Type → Business Info → Tax Info → Payment
  return ['userType', 'business', 'taxInfo', 'payment'];
}

// Usage in component
const [userType, setUserType] = useState<string | null>(null);
const stepFlow = getStepFlow(userType);
const currentIndex = stepFlow.indexOf(currentStep);

// Navigate based on dynamic flow
const goNext = () => {
  if (currentIndex < stepFlow.length - 1) {
    wizard.goToStep(stepFlow[currentIndex + 1]);
  }
};

const goBack = () => {
  if (currentIndex > 0) {
    wizard.goToStep(stepFlow[currentIndex - 1]);
  }
};

// Update flow when user type changes
const selectUserType = (type: 'individual' | 'business') => {
  setUserType(type);
  wizard.updateStepData('userType', { type });
  // Flow automatically updates via getStepFlow()
};
```

## Form Validation with Zod

Integrate Zod for robust schema validation:

<CodePlayground 
  title="Form Validation Playground" 
  height={350}
  code={`// Click Run to test validation
const testData = {
  name: 'Jo',  // Too short!
  email: 'invalid-email',  // Not valid!
  age: 16  // Too young!
};

// Simulate Zod validation
function validateUser(data) {
  const errors = [];
  
  if (data.name.length < 2) {
    errors.push('Name too short');
  }
  if (!data.email.includes('@')) {
    errors.push('Invalid email');
  }
  if (data.age < 18) {
    errors.push('Must be 18 or older');
  }
  
  if (errors.length > 0) {
    return { success: false, errors };
  }
  return { success: true, data };
}

const result = validateUser(testData);
console.log('Validation result:', result);

// Try with valid data
const validData = {
  name: 'John Doe',
  email: 'john@example.com',
  age: 25
};
console.log('Valid data:', validateUser(validData));`}
/>

```typescript
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string().min(2, 'Name too short'),
  email: z.string().email('Invalid email'),
  age: z.number().min(18, 'Must be 18 or older')
});

const wizard = createWizard({
  steps: {
    user: {
      validate: (data) => {
        try {
          UserSchema.parse(data);
        } catch (error) {
          if (error instanceof z.ZodError) {
            throw new Error(error.errors[0].message);
          }
          throw error;
        }
      }
    }
  }
});
```

## Auto-save & Recovery

Automatically save wizard state for recovery:

<AutoSaveDemo />

```typescript
class WizardPersistence {
  private key: string;
  
  constructor(key: string) {
    this.key = key;
  }
  
  setup(wizard: WizardInstance) {
    // Auto-save on changes
    wizard.subscribe((state) => {
      this.save(state);
    });
    
    // Restore on init
    const saved = this.load();
    if (saved) {
      wizard.setState(saved);
    }
  }
  
  save(state: WizardState) {
    localStorage.setItem(this.key, JSON.stringify({
      ...state,
      timestamp: Date.now()
    }));
  }
  
  load(): WizardState | null {
    const saved = localStorage.getItem(this.key);
    if (!saved) return null;
    
    const data = JSON.parse(saved);
    const hourAgo = Date.now() - (60 * 60 * 1000);
    
    // Only restore if less than 1 hour old
    if (data.timestamp > hourAgo) {
      return data;
    }
    
    this.clear();
    return null;
  }
  
  clear() {
    localStorage.removeItem(this.key);
  }
}

// Usage
const persistence = new WizardPersistence('checkout-wizard');
persistence.setup(wizard);
```

## Progress Tracking

Track and display wizard progress:

<ProgressTrackingDemo />

```typescript
function useWizardProgress(wizard: WizardInstance) {
  const [progress, setProgress] = useState(0);
  
  useEffect(() => {
    const unsubscribe = wizard.subscribe((state) => {
      const steps = Object.keys(wizard.config.steps);
      const currentIndex = steps.indexOf(state.currentStep);
      const percentage = ((currentIndex + 1) / steps.length) * 100;
      setProgress(percentage);
    });
    
    return unsubscribe;
  }, [wizard]);
  
  return progress;
}

// Component
function ProgressBar() {
  const progress = useWizardProgress(wizard);
  
  return (
    <div className="w-full bg-gray-200 rounded-full h-2">
      <div 
        className="bg-blue-600 h-2 rounded-full transition-all"
        style={{ width: `${progress}%` }}
      />
    </div>
  );
}
```

## Async Data Loading

Load data asynchronously when entering steps:

<AsyncLoadingDemo />

```typescript
const wizard = createWizard({
  steps: {
    shipping: {
      onEnter: async (context) => {
        // Load shipping options
        const options = await fetchShippingOptions(context.address);
        return {
          ...context,
          shippingOptions: options
        };
      }
    }
  }
});

// React hook for loading state
function useStepLoading() {
  const [loading, setLoading] = useState(false);
  const { goToStep } = useWizard();
  
  const navigateWithLoading = async (step: string) => {
    setLoading(true);
    try {
      await goToStep(step);
    } finally {
      setLoading(false);
    }
  };
  
  return { loading, navigateWithLoading };
}
```

## Multi-page Forms with Router

Sync wizard state with URL routing:

<Tabs items={['TanStack Router', 'Next.js Router']}>
  <Tab label="TanStack Router">
    <RouterDemo />
    
    ```typescript
    import { createRouter } from '@tanstack/react-router';
    
    const wizardRoute = createRoute({
      path: '/checkout/$step',
      component: WizardStep,
      beforeLoad: ({ params }) => {
        // Validate step exists
        if (!wizard.hasStep(params.step)) {
          throw redirect({ to: '/checkout/user' });
        }
      }
    });
    
    function WizardStep() {
      const { step } = useParams();
      const navigate = useNavigate();
      const { nextStep } = useWizard();
      
      const handleNext = async () => {
        await nextStep();
        const newStep = wizard.getCurrentStep();
        navigate({ to: `/checkout/${newStep}` });
      };
      
      return <StepComponent step={step} onNext={handleNext} />;
    }
    ```
  </Tab>
  
  <Tab label="Next.js Router">
    <RouterDemo />
    
    ```typescript
    import { useRouter } from 'next/router';
    
    function WizardPage() {
      const router = useRouter();
      const { step } = router.query;
      const { goToStep, currentStep } = useWizard();
      
      useEffect(() => {
        if (step && step !== currentStep) {
          goToStep(step as string);
        }
      }, [step]);
      
      const handleStepChange = (newStep: string) => {
        router.push(`/wizard/${newStep}`);
      };
      
      return <WizardSteps onStepChange={handleStepChange} />;
    }
    ```
  </Tab>
</Tabs>

## Conditional Validation

Validate based on context or other step data:

<CodePlayground 
  title="Conditional Validation Example"
  height={350}
  code={`// Test conditional validation
const shippingData = { country: 'US' };
const paymentData = { 
  zipCode: '12345',  // Valid US ZIP
  paymentMethod: 'card',
  cardNumber: '4242424242424242',
  cvv: '123'
};

function validatePayment(data, shipping) {
  const errors = [];
  
  // Different validation for US
  if (shipping.country === 'US') {
    if (!data.zipCode || !/^\\d{5}(-\\d{4})?$/.test(data.zipCode)) {
      errors.push('Invalid US ZIP code');
    }
  }
  
  // Validate card payment
  if (data.paymentMethod === 'card') {
    if (!data.cardNumber || !data.cvv) {
      errors.push('Card details required');
    }
  }
  
  return errors.length === 0 
    ? { valid: true } 
    : { valid: false, errors };
}

const result = validatePayment(paymentData, shippingData);
console.log('Validation:', result);

// Test with invalid ZIP
const invalidData = { ...paymentData, zipCode: 'ABC123' };
console.log('Invalid ZIP:', validatePayment(invalidData, shippingData));`}
/>

```typescript
const wizard = createWizard({
  steps: {
    payment: {
      validate: (data, { context, getStepData }) => {
        const shipping = getStepData('shipping');
        
        // Different validation for different countries
        if (shipping?.country === 'US') {
          if (!data.zipCode || !/^\d{5}(-\d{4})?$/.test(data.zipCode)) {
            throw new Error('Invalid US ZIP code');
          }
        }
        
        // Validate based on payment method
        if (context.paymentMethod === 'card') {
          if (!data.cardNumber || !data.cvv) {
            throw new Error('Card details required');
          }
        }
      }
    }
  }
});
```

## Step Timeouts

Add time limits to steps:

<StepTimeoutDemo />

```typescript
class TimedWizard {
  private timers = new Map<string, NodeJS.Timeout>();
  
  constructor(private wizard: WizardInstance) {
    wizard.subscribe(this.handleStepChange);
  }
  
  setStepTimeout(step: string, duration: number, callback: () => void) {
    this.clearStepTimeout(step);
    
    const timer = setTimeout(() => {
      if (this.wizard.getCurrentStep() === step) {
        callback();
      }
    }, duration);
    
    this.timers.set(step, timer);
  }
  
  clearStepTimeout(step: string) {
    const timer = this.timers.get(step);
    if (timer) {
      clearTimeout(timer);
      this.timers.delete(step);
    }
  }
  
  private handleStepChange = (state: WizardState) => {
    // Clear timeout when leaving step
    this.timers.forEach((timer, step) => {
      if (step !== state.currentStep) {
        this.clearStepTimeout(step);
      }
    });
  };
}

// Usage
const timed = new TimedWizard(wizard);
timed.setStepTimeout('payment', 5 * 60 * 1000, () => {
  alert('Session timeout - please complete payment');
  wizard.reset();
});
```

## Step Status Management

Comprehensive status system with 9 distinct states for granular control:

<StatusSystemDemo />

### Using Status System

```typescript
const wizard = createWizard(config);

// Check step status
const paymentStatus = wizard.helpers.stepStatus('payment');
switch (paymentStatus) {
  case 'unavailable':
    // Step is blocked by prerequisites
    showMessage('Complete previous steps first');
    break;
  case 'error':
    // Step failed but can be retried
    const attempts = wizard.helpers.stepAttempts('payment');
    if (attempts < 3) {
      showRetryButton();
    } else {
      wizard.markTerminated('payment');
    }
    break;
  case 'loading':
    // Async operation in progress
    showSpinner();
    break;
  case 'completed':
    // Step finished successfully
    showCheckmark();
    break;
}

// React to status changes
config.onStatusChange = ({ step, prev, next }) => {
  analytics.track('step_status_changed', {
    step,
    previousStatus: prev,
    newStatus: next,
    timestamp: Date.now()
  });
};
```

## Advanced Navigation with Helpers

30+ helper methods for intelligent wizard navigation:

<HelpersShowcaseDemo />

### Smart Navigation Pattern

```typescript
function SmartWizardNavigation() {
  const wizard = useWizard();
  const helpers = wizard.helpers;

  const handleNext = async () => {
    // Skip optional steps if user wants
    if (userWantsToSkip && helpers.isOptional(currentStep)) {
      const nextRequired = helpers.jumpToNextRequired();
      if (nextRequired) {
        await wizard.goTo(nextRequired);
        return;
      }
    }

    // Normal navigation
    if (helpers.canGoNext()) {
      const next = helpers.findNextAvailable();
      await wizard.goTo(next);
    }
  };

  const handleSkipToEnd = async () => {
    // Mark all optional steps as skipped
    const remaining = helpers.remainingSteps();
    for (const step of remaining) {
      if (helpers.isOptional(step)) {
        wizard.markSkipped(step);
      }
    }

    // Jump to last required step
    const lastRequired = [...helpers.orderedSteps()]
      .reverse()
      .find(s => helpers.isRequired(s));

    if (lastRequired && helpers.canGoTo(lastRequired)) {
      await wizard.goTo(lastRequired);
    }
  };

  return {
    canSkip: helpers.isOptional(currentStep),
    canGoBack: helpers.canGoBack(),
    canGoNext: helpers.canGoNext(),
    progress: helpers.progress(),
    handleNext,
    handleSkipToEnd
  };
}
```

## DAG Prerequisites & Topological Sorting

Define complex step dependencies with automatic ordering:

<DAGPrerequisitesDemo />

### Complex Flow with Prerequisites

```typescript
const config: WizardConfig = {
  // Define prerequisites - creates a DAG
  prerequisites: {
    'account': [],                           // No prerequisites
    'personal-info': ['account'],            // Requires account
    'business-info': ['account'],            // Also requires account
    'verification': ['personal-info'],       // Requires personal info
    'tax-setup': ['business-info'],          // Requires business info
    'payment': ['verification', 'tax-setup'], // Requires both paths
    'review': ['payment'],                   // Final review
    'complete': ['review']                   // Completion
  },

  // Steps will be automatically ordered via topological sort
  // No need to specify order manually!

  steps: {
    // Step definitions...
  }
};

// Check if prerequisites are met
function canProceedToPayment() {
  const prereqsMet = wizard.helpers.isReachable('payment');
  if (!prereqsMet) {
    const missing = wizard.helpers.prerequisitesFor('payment')
      .filter(p => wizard.helpers.stepStatus(p) !== 'completed');

    showMessage(`Complete these steps first: ${missing.join(', ')}`);
    return false;
  }
  return true;
}
```

## Weighted Progress Calculation

More accurate progress tracking with step weights:

<WeightedProgressDemo />

### Implementing Weighted Progress

```typescript
const config: WizardConfig = {
  // Assign weights based on complexity/importance
  weights: {
    'intro': 1,          // Quick intro
    'terms': 1,          // Simple agreement
    'identity': 5,       // Complex verification
    'documents': 4,      // Document upload
    'review': 2,         // Review step
    'payment': 3,        // Payment processing
    'confirmation': 1    // Final confirmation
  },

  // Use weighted progress
  steps: { /* ... */ }
};

// Display progress
function ProgressDisplay() {
  const { ratio, percent, label } = wizard.helpers.progress();

  return (
    <div>
      {/* Weighted progress bar */}
      <div className="progress-bar">
        <div
          className="progress-fill"
          style={{ width: `${percent}%` }}
        />
      </div>

      {/* Show both metrics */}
      <div className="progress-info">
        <span>Progress: {percent}%</span>
        <span>Steps: {label}</span>

        {/* Time estimate based on weights */}
        <span>
          Est. time remaining: {calculateTimeRemaining(ratio)}
        </span>
      </div>
    </div>
  );
}

function calculateTimeRemaining(completionRatio: number) {
  const avgTimePerWeight = 2; // minutes
  const remainingWeight = (1 - completionRatio) * totalWeight;
  const minutes = Math.ceil(remainingWeight * avgTimePerWeight);
  return `${minutes} min`;
}
```

## Error Recovery with Retry Logic

Handle errors gracefully with automatic retry:

```typescript
async function handleStepWithRetry(
  step: string,
  data: any,
  maxAttempts = 3
) {
  const attempts = wizard.helpers.stepAttempts(step);

  try {
    wizard.markLoading(step);

    // Attempt to process step
    await processStepData(step, data);

    // Success - mark complete
    wizard.markIdle(step);
    await wizard.next();

  } catch (error) {
    wizard.markIdle(step);

    if (attempts >= maxAttempts) {
      // Max attempts reached
      wizard.markTerminated(step, error);

      // Check if step is optional
      if (wizard.helpers.isOptional(step)) {
        // Skip and continue
        wizard.markSkipped(step);
        const next = wizard.helpers.findNextAvailable();
        if (next) {
          await wizard.goTo(next);
        }
      } else {
        // Required step failed - show error UI
        showErrorDialog({
          title: 'Step Failed',
          message: `Unable to complete ${step} after ${maxAttempts} attempts`,
          actions: ['Contact Support', 'Start Over']
        });
      }
    } else {
      // Mark as error and allow retry
      wizard.markError(step, error);

      // Show retry UI with attempt count
      showRetryPrompt({
        step,
        attempt: attempts + 1,
        maxAttempts,
        onRetry: () => handleStepWithRetry(step, data, maxAttempts)
      });
    }
  }
}
```

## Runtime Performance Tracking

Monitor step performance and optimize UX:

```typescript
// Track step performance
function useStepMetrics() {
  const wizard = useWizard();
  const [metrics, setMetrics] = useState<StepMetrics[]>([]);

  useEffect(() => {
    return wizard.subscribe((state) => {
      const currentMetrics = wizard.helpers.orderedSteps().map(step => ({
        step,
        status: wizard.helpers.stepStatus(step),
        attempts: wizard.helpers.stepAttempts(step),
        duration: wizard.helpers.stepDuration(step),
        isBottleneck: false
      }));

      // Identify bottlenecks
      const avgDuration = currentMetrics
        .filter(m => m.duration)
        .reduce((sum, m) => sum + m.duration!, 0) / currentMetrics.length;

      currentMetrics.forEach(m => {
        if (m.duration && m.duration > avgDuration * 2) {
          m.isBottleneck = true;
        }
      });

      setMetrics(currentMetrics);
    });
  }, [wizard]);

  return metrics;
}

// Performance dashboard
function PerformanceDashboard() {
  const metrics = useStepMetrics();

  return (
    <div className="metrics-dashboard">
      <h3>Step Performance</h3>

      {metrics.map(metric => (
        <div key={metric.step} className={metric.isBottleneck ? 'bottleneck' : ''}>
          <span>{metric.step}</span>
          <span>{metric.duration ? `${metric.duration}ms` : '-'}</span>
          <span>{metric.attempts} attempts</span>

          {metric.isBottleneck && (
            <span className="warning">⚠️ Bottleneck detected</span>
          )}
        </div>
      ))}

      <div className="summary">
        <div>Total time: {calculateTotalTime(metrics)}ms</div>
        <div>Retry rate: {calculateRetryRate(metrics)}%</div>
        <div>Completion rate: {calculateCompletionRate(metrics)}%</div>
      </div>
    </div>
  );
}
```

## Analytics Integration

Track wizard interactions:

<AnalyticsDemo />

```typescript
const analyticsPlugin = {
  install(wizard: WizardInstance) {
    wizard.subscribe((state, prevState) => {
      // Track step changes
      if (state.currentStep !== prevState?.currentStep) {
        analytics.track('wizard_step_viewed', {
          step: state.currentStep,
          from: prevState?.currentStep
        });
      }
      
      // Track completions
      const isLastStep = wizard.getNextSteps().length === 0;
      if (isLastStep && state.stepData[state.currentStep]) {
        analytics.track('wizard_completed', {
          steps: Object.keys(state.stepData)
        });
      }
    });
    
    // Track errors
    const originalValidate = wizard.validateStep;
    wizard.validateStep = async function(...args) {
      try {
        return await originalValidate.apply(this, args);
      } catch (error) {
        analytics.track('wizard_validation_error', {
          step: wizard.getCurrentStep(),
          error: error.message
        });
        throw error;
      }
    };
  }
};

// Usage
analyticsPlugin.install(wizard);
```

<style jsx>{`
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
`}</style>

<Callout type="info" title="More Examples">
  Check out the [Examples](/examples) section for complete, runnable implementations of these patterns.
</Callout>