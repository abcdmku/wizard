# @wizard/react API Reference

Complete API reference for the React adapter library.

import { Callout, Badge, Tabs, Tab } from '../../components'

## Provider Component

### `WizardProvider`

Context provider that makes wizard instance available to child components.

```typescript
function WizardProvider<C, S extends string, D extends Record<S, unknown>, E = never>(
  props: WizardProviderProps<C, S, D, E>
): JSX.Element
```

**Props:**
```typescript
type WizardProviderProps<C, S, D, E> = {
  wizard: Wizard<C, S, D, E>;  // Wizard instance from createWizard()
  children: React.ReactNode;    // Child components
}
```

**Example:**
```typescript
import { createWizard } from '@wizard/core';
import { WizardProvider } from '@wizard/react';

const wizard = createWizard(config);

function App() {
  return (
    <WizardProvider wizard={wizard}>
      <WizardSteps />
    </WizardProvider>
  );
}
```

## Core Hooks

### `useWizard`

Returns the complete wizard instance with all methods and helpers.

```typescript
function useWizard<C, S extends string, D extends Record<S, unknown>, E = never>():
  Wizard<C, S, D, E>
```

**Returns:** Complete wizard instance

**Example:**
```typescript
function StepComponent() {
  const wizard = useWizard();

  const handleNext = async () => {
    await wizard.next({ data: formData });
  };

  const progress = wizard.helpers.progress();

  return (
    <div>
      <p>Progress: {progress.percent}%</p>
      <button onClick={handleNext}>Next</button>
    </div>
  );
}
```

### `useWizardState`

Returns the current wizard state with reactive updates.

```typescript
function useWizardState<C, S extends string, D extends Record<S, unknown>>():
  WizardState<C, S, D>
```

**Returns:** Current wizard state (reactive)

**Example:**
```typescript
function ProgressBar() {
  const state = useWizardState();

  return (
    <div>
      <p>Current step: {state.step}</p>
      <p>Loading: {state.isLoading ? 'Yes' : 'No'}</p>
      <p>Errors: {Object.keys(state.errors).length}</p>
    </div>
  );
}
```

### `useWizardStep`

Returns the current step ID with reactive updates.

```typescript
function useWizardStep<S extends string>(): S
```

**Returns:** Current step ID

**Example:**
```typescript
function StepIndicator() {
  const currentStep = useWizardStep();

  return (
    <div>
      Current: {currentStep}
    </div>
  );
}
```

### `useWizardSharedContext`

Returns the shared context object with reactive updates.

```typescript
function useWizardSharedContext<C>(): C
```

**Returns:** Current context object

**Example:**
```typescript
function UserInfo() {
  const context = useWizardSharedContext<{ userId: string }>();

  return (
    <div>
      User ID: {context.userId}
    </div>
  );
}
```

### `useStepData`

Returns data for a specific step with reactive updates.

```typescript
function useStepData<D, S extends string>(step: S): D[S] | undefined
```

**Parameters:**
- `step` - Step ID to get data for

**Returns:** Step data or undefined

**Example:**
```typescript
function ReviewStep() {
  const userData = useStepData('user');
  const shippingData = useStepData('shipping');

  return (
    <div>
      <h3>Review Your Information</h3>
      <p>Name: {userData?.name}</p>
      <p>Address: {shippingData?.address}</p>
    </div>
  );
}
```

### `useCurrentStepData`

Returns data for the current step with reactive updates.

```typescript
function useCurrentStepData<D, S extends string>(): D[S] | undefined
```

**Returns:** Current step data or undefined

**Example:**
```typescript
function CurrentStepForm() {
  const currentData = useCurrentStepData();

  return (
    <form>
      {/* Render form based on currentData */}
      <pre>{JSON.stringify(currentData, null, 2)}</pre>
    </form>
  );
}
```

### `useWizardLoading`

Returns the loading state with reactive updates.

```typescript
function useWizardLoading(): boolean
```

**Returns:** Loading state

**Example:**
```typescript
function LoadingIndicator() {
  const isLoading = useWizardLoading();

  if (isLoading) {
    return <Spinner />;
  }

  return null;
}
```

### `useWizardTransitioning`

Returns the transitioning state with reactive updates.

```typescript
function useWizardTransitioning(): boolean
```

**Returns:** Transitioning state

**Example:**
```typescript
function NavigationButtons() {
  const isTransitioning = useWizardTransitioning();

  return (
    <button disabled={isTransitioning}>
      {isTransitioning ? 'Processing...' : 'Next'}
    </button>
  );
}
```

### `useWizardHistory`

Returns the navigation history with reactive updates.

```typescript
function useWizardHistory<C, S extends string, D>(): Array<{
  step: S;
  context: C;
  data: Partial<D>;
}>
```

**Returns:** History array

**Example:**
```typescript
function HistoryDebugger() {
  const history = useWizardHistory();

  return (
    <div>
      <h4>History ({history.length} entries)</h4>
      {history.map((entry, i) => (
        <div key={i}>Step: {entry.step}</div>
      ))}
    </div>
  );
}
```

### `useWizardErrors`

Returns validation errors with reactive updates.

```typescript
function useWizardErrors<S extends string>(): Partial<Record<S, unknown>>
```

**Returns:** Error map

**Example:**
```typescript
function ErrorDisplay() {
  const errors = useWizardErrors();
  const currentStep = useWizardStep();
  const currentError = errors[currentStep];

  if (currentError) {
    return (
      <div className="error">
        {String(currentError)}
      </div>
    );
  }

  return null;
}
```

### `useWizardActions`

Returns memoized action handlers for common wizard operations.

```typescript
function useWizardActions<C, S extends string, D extends Record<S, unknown>, E>(): {
  next: (data?: D[S]) => Promise<void>;
  back: () => Promise<void>;
  goTo: (step: S, data?: D[S]) => Promise<void>;
  reset: () => void;
  updateContext: (updater: (ctx: C) => void) => void;
  setStepData: (step: S, data: D[S]) => void;
  emit: (event: E) => void;
}
```

**Returns:** Object with action handlers

**Example:**
```typescript
function WizardControls() {
  const { next, back, reset } = useWizardActions();

  return (
    <div>
      <button onClick={back}>Previous</button>
      <button onClick={() => next()}>Next</button>
      <button onClick={reset}>Start Over</button>
    </div>
  );
}
```

## Router Integration Hooks

### `useSyncWizardWithRouter`

Generic hook to sync wizard state with any router.

```typescript
function useSyncWizardWithRouter<S extends string>(
  options: SyncWizardWithRouterOptions<S>
): void
```

**Options:**
```typescript
type SyncWizardWithRouterOptions<S extends string> = {
  getCurrentPath: () => string;           // Get current URL path
  navigate: (path: string) => void;       // Navigate to path
  getStepFromPath: (path: string) => S | null;  // Extract step from path
  getPathFromStep: (step: S) => string;   // Generate path from step
  syncDirection?: 'wizard-to-router' | 'router-to-wizard' | 'both';  // default: 'both'
}
```

**Example with Next.js:**
```typescript
import { useRouter } from 'next/router';
import { useSyncWizardWithRouter } from '@wizard/react';

function WizardPage() {
  const router = useRouter();

  useSyncWizardWithRouter({
    getCurrentPath: () => router.pathname,
    navigate: (path) => router.push(path),
    getStepFromPath: (path) => {
      const match = path.match(/\/wizard\/(\w+)/);
      return match ? match[1] as Steps : null;
    },
    getPathFromStep: (step) => `/wizard/${step}`,
  });

  return <WizardSteps />;
}
```

### `useTanStackRouterSync`

Specialized hook for TanStack Router integration.

```typescript
function useTanStackRouterSync<S extends string>(options: {
  paramName?: string;  // default: 'step'
}): void
```

**Example:**
```typescript
import { useTanStackRouterSync } from '@wizard/react';

function WizardRoute() {
  // Automatically syncs with TanStack Router
  useTanStackRouterSync({ paramName: 'step' });

  return <WizardContent />;
}

// Router configuration
const wizardRoute = createRoute({
  path: '/wizard/$step',
  component: WizardRoute
});
```

## Complete React Example

```typescript
import React from 'react';
import { createWizard } from '@wizard/core';
import {
  WizardProvider,
  useWizard,
  useWizardState,
  useWizardActions,
  useStepData
} from '@wizard/react';

// Create wizard (same as core example)
const wizard = createWizard(config);

// Main App
function App() {
  return (
    <WizardProvider wizard={wizard}>
      <WizardContainer />
    </WizardProvider>
  );
}

// Container Component
function WizardContainer() {
  const state = useWizardState();
  const wizard = useWizard();

  return (
    <div>
      <ProgressBar />
      <StepIndicator />

      {/* Render current step */}
      {state.step === 'user' && <UserStep />}
      {state.step === 'shipping' && <ShippingStep />}
      {state.step === 'payment' && <PaymentStep />}
      {state.step === 'review' && <ReviewStep />}
      {state.step === 'confirm' && <ConfirmStep />}

      <NavigationButtons />
      <ErrorDisplay />
    </div>
  );
}

// Progress Component
function ProgressBar() {
  const wizard = useWizard();
  const progress = wizard.helpers.progress();

  return (
    <div className="progress-bar">
      <div
        className="progress-fill"
        style={{ width: `${progress.percent}%` }}
      />
      <span>{progress.label}</span>
    </div>
  );
}

// Step Indicator
function StepIndicator() {
  const wizard = useWizard();
  const currentStep = useWizardStep();
  const steps = wizard.helpers.orderedSteps();

  return (
    <div className="steps">
      {steps.map(step => {
        const status = wizard.helpers.stepStatus(step);
        return (
          <div
            key={step}
            className={`step step--${status}`}
            onClick={() => {
              if (wizard.helpers.canGoTo(step)) {
                wizard.goTo(step);
              }
            }}
          >
            {step}
          </div>
        );
      })}
    </div>
  );
}

// Example Step Component
function UserStep() {
  const { next } = useWizardActions();
  const currentData = useCurrentStepData<UserData>();
  const [formData, setFormData] = useState(currentData || {
    name: '',
    email: ''
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await next(formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <h2>User Information</h2>
      <input
        type="text"
        placeholder="Name"
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
      />
      <input
        type="email"
        placeholder="Email"
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
      />
      <button type="submit">Continue</button>
    </form>
  );
}

// Review Step
function ReviewStep() {
  const wizard = useWizard();
  const userData = useStepData('user');
  const shippingData = useStepData('shipping');
  const paymentData = useStepData('payment');
  const { next, goTo } = useWizardActions();

  return (
    <div>
      <h2>Review Your Order</h2>

      <section onClick={() => goTo('user')}>
        <h3>User Info</h3>
        <p>{userData?.name}</p>
        <p>{userData?.email}</p>
      </section>

      <section onClick={() => goTo('shipping')}>
        <h3>Shipping</h3>
        <p>{shippingData?.address}</p>
        <p>{shippingData?.method}</p>
      </section>

      <section onClick={() => goTo('payment')}>
        <h3>Payment</h3>
        <p>Card ending in {paymentData?.cardNumber.slice(-4)}</p>
      </section>

      <button onClick={() => next({ accepted: true })}>
        Place Order
      </button>
    </div>
  );
}

// Navigation Controls
function NavigationButtons() {
  const wizard = useWizard();
  const { back, reset } = useWizardActions();
  const isTransitioning = useWizardTransitioning();

  const canGoBack = wizard.helpers.canGoBack();
  const canGoNext = wizard.helpers.canGoNext();
  const isComplete = wizard.helpers.isComplete();

  return (
    <div className="navigation">
      <button
        onClick={back}
        disabled={!canGoBack || isTransitioning}
      >
        Back
      </button>

      <button
        onClick={() => wizard.next()}
        disabled={!canGoNext || isTransitioning}
      >
        {isComplete ? 'Finish' : 'Next'}
      </button>

      <button onClick={reset}>
        Start Over
      </button>
    </div>
  );
}

// Error Display
function ErrorDisplay() {
  const errors = useWizardErrors();
  const currentStep = useWizardStep();
  const wizard = useWizard();

  const currentError = errors[currentStep];
  const stepStatus = wizard.helpers.stepStatus(currentStep);
  const attempts = wizard.helpers.stepAttempts(currentStep);

  if (!currentError) return null;

  return (
    <div className={`error error--${stepStatus}`}>
      <p>{String(currentError)}</p>
      {stepStatus === 'error' && attempts < 3 && (
        <button onClick={() => wizard.markIdle(currentStep)}>
          Try Again ({3 - attempts} attempts remaining)
        </button>
      )}
      {stepStatus === 'terminated' && (
        <p>This step has permanently failed. Please contact support.</p>
      )}
    </div>
  );
}
```

## Advanced Patterns

### Custom Hook Composition

Create custom hooks that combine multiple wizard hooks:

```typescript
function useWizardProgress() {
  const wizard = useWizard();
  const state = useWizardState();

  return useMemo(() => {
    const progress = wizard.helpers.progress();
    const remaining = wizard.helpers.remainingRequiredCount();
    const isStalled = ['error', 'terminated'].includes(
      wizard.helpers.stepStatus(state.step)
    );

    return {
      ...progress,
      remaining,
      isStalled,
      canContinue: wizard.helpers.canGoNext()
    };
  }, [wizard, state.step]);
}
```

### Optimistic Updates

Handle async operations with optimistic UI updates:

```typescript
function useOptimisticSubmit() {
  const wizard = useWizard();
  const currentStep = useWizardStep();
  const { next } = useWizardActions();

  const submit = useCallback(async (data: any) => {
    // Optimistically mark as loading
    wizard.markLoading(currentStep);

    try {
      // Validate and save
      await validateStepData(data);
      await next(data);
    } catch (error) {
      // Revert on error
      wizard.markError(currentStep, error);
      throw error;
    } finally {
      wizard.markIdle(currentStep);
    }
  }, [wizard, currentStep, next]);

  return submit;
}
```

### Step Prefetching

Prefetch data for upcoming steps:

```typescript
function usePrefetchNextStep() {
  const wizard = useWizard();
  const currentStep = useWizardStep();

  useEffect(() => {
    const nextStep = wizard.helpers.findNextAvailable();
    if (nextStep) {
      // Prefetch data for next step
      prefetchStepData(nextStep);
    }
  }, [wizard, currentStep]);
}
```

<Callout type="info">
For complete type definitions, see the [@wizard/core API Reference](/api/core).
</Callout>