# Progress Helpers

import { Callout } from '../../components'

Progress helpers provide methods to track completion status, calculate progress percentages, and determine remaining work in your wizard.

## Overview

Progress helpers enable you to:
- Calculate overall wizard completion percentage
- Track per-step completion rates
- Count remaining required steps
- Determine if the wizard is fully complete
- Support weighted progress calculations

## Core Progress Methods

### Overall Progress

```typescript
const helpers = createHelpers(wizard);

// Get overall progress (0-100)
const progressPercent = helpers.progress();
console.log(`Wizard is ${progressPercent}% complete`);

// Check if wizard is fully complete
const isComplete = helpers.isComplete();
if (isComplete) {
  console.log('All required steps completed!');
}

// Count remaining required steps
const remainingCount = helpers.remainingRequiredCount();
console.log(`${remainingCount} required steps left`);
```

### Per-Step Progress

```typescript
// Get completion percentage for each step
const stepProgress = helpers.percentCompletePerStep();
console.log(stepProgress);
// Output:
// {
//   userInfo: 100,    // Completed
//   shipping: 100,    // Completed
//   payment: 0,       // Not started
//   confirmation: 0   // Not started
// }

// Use for progress visualization
Object.entries(stepProgress).forEach(([step, percent]) => {
  console.log(`${step}: ${percent}% complete`);
});
```

### Completion Tracking

```typescript
// Get list of completed steps
const completed = helpers.completedSteps();
console.log('Completed:', completed);
// Output: ['userInfo', 'shipping']

// Get list of remaining steps
const remaining = helpers.remainingSteps();
console.log('Remaining:', remaining);
// Output: ['payment', 'confirmation']

// Find first incomplete step
const nextToDo = helpers.firstIncompleteStep();
if (nextToDo) {
  console.log(`Next step to complete: ${nextToDo}`);
}

// Find last completed step
const lastDone = helpers.lastCompletedStep();
if (lastDone) {
  console.log(`Last completed: ${lastDone}`);
}
```

## Advanced Progress Patterns

### Weighted Progress Calculation

When steps have different importance or complexity, you can use weights:

```typescript
const wizard = createWizard({
  steps: {
    userInfo: {
      weight: 1,  // Simple form
      // ... other config
    },
    shipping: {
      weight: 1,  // Simple form
      // ... other config
    },
    payment: {
      weight: 3,  // Complex payment flow
      // ... other config
    },
    confirmation: {
      weight: 0.5,  // Quick review
      // ... other config
    }
  }
});

const helpers = createHelpers(wizard);

// Progress now considers weights
const weightedProgress = helpers.progress();
// If userInfo and shipping are complete:
// (1 + 1) / (1 + 1 + 3 + 0.5) = 2/5.5 ≈ 36%
```

### Progress with Optional Steps

```typescript
const wizard = createWizard({
  steps: {
    userInfo: {
      required: true,
      // ...
    },
    preferences: {
      required: false,  // Optional step
      // ...
    },
    payment: {
      required: true,
      // ...
    }
  }
});

const helpers = createHelpers(wizard);

// Progress only counts required steps by default
const progress = helpers.progress();
// Optional steps don't affect completion percentage

// But you can track them separately
const allSteps = helpers.percentCompletePerStep();
const optionalProgress = Object.entries(allSteps)
  .filter(([step]) => helpers.isOptional(step))
  .reduce((acc, [_, percent]) => acc + percent, 0) /
  Object.keys(allSteps).filter(step => helpers.isOptional(step)).length;
```

### Custom Progress Calculations

```typescript
class CustomProgressTracker {
  constructor(
    private helpers: WizardHelpers<Context, Steps, Data>
  ) {}

  // Progress based on user-defined milestones
  getMilestoneProgress(): number {
    const milestones = {
      'Account Created': ['userInfo'],
      'Shipping Set': ['shipping'],
      'Payment Added': ['payment'],
      'Order Placed': ['confirmation']
    };

    const completed = this.helpers.completedSteps();
    let milestonesComplete = 0;

    Object.values(milestones).forEach(requiredSteps => {
      if (requiredSteps.every(step => completed.includes(step))) {
        milestonesComplete++;
      }
    });

    return (milestonesComplete / Object.keys(milestones).length) * 100;
  }

  // Time-based progress
  getTimeBasedProgress(): number {
    const steps = this.helpers.allSteps();
    const totalExpectedTime = steps.length * 60000; // 1 min per step expected

    let actualTime = 0;
    steps.forEach(step => {
      const duration = this.helpers.stepDuration(step);
      if (duration) {
        actualTime += duration;
      }
    });

    // Progress based on time efficiency
    return Math.min(100, (actualTime / totalExpectedTime) * 100);
  }

  // Attempt-based progress (fewer attempts = better)
  getQualityProgress(): number {
    const steps = this.helpers.allSteps();
    let qualityScore = 0;

    steps.forEach(step => {
      const attempts = this.helpers.stepAttempts(step);
      if (attempts === 0) return; // Not attempted yet

      // Perfect score for first-try success
      if (attempts === 1) {
        qualityScore += 100;
      } else {
        // Decrease score for multiple attempts
        qualityScore += Math.max(0, 100 - (attempts - 1) * 20);
      }
    });

    const attemptedSteps = steps.filter(
      step => this.helpers.stepAttempts(step) > 0
    ).length;

    return attemptedSteps > 0 ? qualityScore / attemptedSteps : 0;
  }
}
```

## UI Components

### Progress Bar Component

```tsx
function WizardProgressBar() {
  const helpers = createHelpers(wizard);
  const progress = helpers.progress();

  return (
    <div className="w-full bg-gray-200 rounded-full h-2">
      <div
        className="bg-blue-600 h-2 rounded-full transition-all"
        style={{ width: `${progress}%` }}
      />
      <span className="text-sm text-gray-600 mt-1">
        {progress}% Complete
      </span>
    </div>
  );
}
```

### Step Progress Indicators

```tsx
function StepProgressIndicators() {
  const helpers = createHelpers(wizard);
  const stepProgress = helpers.percentCompletePerStep();

  return (
    <div className="space-y-4">
      {Object.entries(stepProgress).map(([step, percent]) => (
        <div key={step} className="flex items-center gap-4">
          <span className="w-24 text-sm font-medium">{step}</span>
          <div className="flex-1 bg-gray-200 rounded-full h-2">
            <div
              className={`h-2 rounded-full transition-all ${
                percent === 100 ? 'bg-green-500' : 'bg-blue-500'
              }`}
              style={{ width: `${percent}%` }}
            />
          </div>
          <span className="text-sm text-gray-600">{percent}%</span>
        </div>
      ))}
    </div>
  );
}
```

### Remaining Steps Counter

```tsx
function RemainingStepsCounter() {
  const helpers = createHelpers(wizard);
  const remaining = helpers.remainingRequiredCount();
  const total = helpers.allSteps().filter(
    step => helpers.isRequired(step)
  ).length;

  return (
    <div className="card">
      <div className="text-center">
        <div className="text-3xl font-bold">
          {total - remaining} / {total}
        </div>
        <div className="text-gray-600">Steps Complete</div>
        {remaining > 0 && (
          <div className="text-sm text-blue-600 mt-2">
            {remaining} required step{remaining !== 1 ? 's' : ''} remaining
          </div>
        )}
      </div>
    </div>
  );
}
```

## Real-World Examples

### E-commerce Checkout Progress

```typescript
function CheckoutProgress() {
  const helpers = createHelpers(checkoutWizard);
  const progress = helpers.progress();
  const currentStep = wizard.getCurrentStep();

  const stages = [
    { name: 'Cart', steps: ['cart'] },
    { name: 'Shipping', steps: ['shipping'] },
    { name: 'Payment', steps: ['payment', 'billing'] },
    { name: 'Review', steps: ['review'] },
    { name: 'Complete', steps: ['confirmation'] }
  ];

  const getStageProgress = (stageSteps: string[]) => {
    const completed = stageSteps.filter(
      step => helpers.stepStatus(step) === 'completed'
    ).length;
    return (completed / stageSteps.length) * 100;
  };

  return (
    <div className="checkout-progress">
      {stages.map((stage, index) => {
        const stageProgress = getStageProgress(stage.steps);
        const isActive = stage.steps.includes(currentStep);

        return (
          <div
            key={stage.name}
            className={`stage ${isActive ? 'active' : ''}`}
          >
            <div className="stage-icon">
              {stageProgress === 100 ? '✓' : index + 1}
            </div>
            <div className="stage-name">{stage.name}</div>
            <div className="stage-progress">
              {stageProgress > 0 && stageProgress < 100 && (
                <div className="mini-progress">
                  <div style={{ width: `${stageProgress}%` }} />
                </div>
              )}
            </div>
          </div>
        );
      })}
    </div>
  );
}
```

### Onboarding Progress with Gamification

```typescript
function OnboardingProgress() {
  const helpers = createHelpers(onboardingWizard);

  const achievements = {
    'Quick Start': {
      requirement: () => helpers.stepDuration('welcome') < 30000,
      points: 10
    },
    'Profile Complete': {
      requirement: () => helpers.stepStatus('profile') === 'completed',
      points: 20
    },
    'First Try Success': {
      requirement: () => helpers.stepAttempts('verification') === 1,
      points: 15
    },
    'All Optional Complete': {
      requirement: () => {
        const optional = helpers.allSteps().filter(
          step => helpers.isOptional(step)
        );
        return optional.every(
          step => helpers.stepStatus(step) === 'completed'
        );
      },
      points: 25
    }
  };

  const earnedPoints = Object.entries(achievements)
    .filter(([_, achievement]) => achievement.requirement())
    .reduce((total, [_, achievement]) => total + achievement.points, 0);

  const totalPoints = Object.values(achievements)
    .reduce((total, achievement) => total + achievement.points, 0);

  return (
    <div>
      <h3>Onboarding Progress</h3>
      <div className="progress-stats">
        <div>Progress: {helpers.progress()}%</div>
        <div>Points: {earnedPoints}/{totalPoints}</div>
        <div>Level: {Math.floor(earnedPoints / 20) + 1}</div>
      </div>
    </div>
  );
}
```

## Performance Considerations

<Callout type="warning" title="Performance Tips">
1. **Cache helper instances** - Don't recreate helpers on every render
2. **Use React.memo** - Memoize progress components to avoid unnecessary re-renders
3. **Debounce updates** - For real-time progress, debounce frequent updates
4. **Selective subscriptions** - Only subscribe to specific progress metrics you need
</Callout>

### Optimized Progress Hook

```typescript
function useOptimizedProgress() {
  const wizard = useWizard();
  const helpers = useMemo(() => createHelpers(wizard), [wizard]);

  const [progress, setProgress] = useState(() => helpers.progress());

  useEffect(() => {
    // Debounce progress updates
    const updateProgress = debounce(() => {
      setProgress(helpers.progress());
    }, 100);

    const unsubscribe = wizard.subscribe(updateProgress);
    return unsubscribe;
  }, [wizard, helpers]);

  return progress;
}
```

## Best Practices

1. **Show meaningful progress** - Use weighted steps for accurate representation
2. **Provide context** - Show what's completed and what's remaining
3. **Handle edge cases** - Account for optional steps and branching flows
4. **Update in real-time** - Keep progress indicators current
5. **Celebrate milestones** - Acknowledge completion of major sections

## Next Steps

- Explore [Availability Helpers](/helpers/availability) for dynamic step management
- Learn about [Requirements Helpers](/helpers/requirements) for dependency tracking
- Master [Diagnostics Helpers](/helpers/diagnostics) for performance monitoring